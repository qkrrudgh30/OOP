<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>OOP Chapter 01 Java 기본 문법</title>

        <link rel="stylesheet" href="../font/font.css">

    </head>
    <body>
        <h1>Chapter 01. Java 기본 문법</h1>
        <h2>1.0 Hello, world!</h2>
        <h4>1.0-0 Hello, world! 출력하기</h4>
        <p>
            <a href="">- Ex010000_HelloWorld</a><br><br>
            
        </p>
        <h4>1.0-1 public class HelloWorld {}</h4>
        <p>
            - &#60접근제어자&#62 class &#60클래스명&#62 { <br>
                ... <br>
            } <br><br>
            - Java에서는 언제나 클래스가 필요합니다. <br>
              모든 함수와 변수는 클래스 내에 속합니다. <br><br>

            - 한 개의 .java 파일 내에는 최고 레벨 public 클래스가 하나만 존재해야 합니다. <br>
              둘 이상일 경우 컴파일이 되지 않습니다. <br><br>

            <a href="">- Ex010001_duplicated_public_class</a><br><br>

        </p>
        <h4>1.0-2 내포 클래스</h4>
        <p>
            - 클래스 안에 또 다른 클래스를 넣을 수 있습니다. <br>
              안에 있는 클래스를 내포(nested) 클래스라 부릅니다. <br>
              중첩 클래스, 내부 클래스라고도 부릅니다. <br><br>

            - 이때 내포 클래스는 public이어도 상관없습니다. <br><br>

            <a href="">- Ex010002_nested_class</a><br><br>

        </p>
        <h4>1.0-3 main 함수</h4>
        <p>
            - public static void main(String[] args) { <br>
                ... <br>
            } <br><br>

            - 프로그램의 시작점(entry point)입니다. <br><br>

            - 반드시 위 시그니처(Signature)대로 main함수를 만들어야합니다. <br><br>

            <a href="">- Ex010003_main_with_wrong_signature</a><br><br>

            - main 함수의 매개변수인 String[] args는 문자열 배열입니다. <br>
              커맨드라인으로부터 받은 인자를 저장하는 매개변수입니다. <br><br>

        </p>
        <h4>1.0-4 System.out.println("Hello, world!");</h4>
        <p>
            - 표준 출력(Standard output)으로 한 줄을 출력하는 함수입니다. <br>
              System은 클래스이고, out은 System 클래스의 정적(static) 멤버 변수입니다. <br>
              out의 자료형은 PrintStream 클래스입니다. 즉, out은 개체(Object)입니다. <br>
              PrintStream 클래스는 Java의 표준 출력 스트림입니다. <br>
              이 out 정적 멤버 변수의 메서드 중 하나인 println()은 숫자, 문자, 문자열 등을 출력할 수 있게 해주는 함수입니다. <br>
              이것이 가능한 이유는 함수 오버로딩(Overloading)덕분입니다. <br>
              여기서 ln은 line의 약자입니다. <br><br>

            <a href="">- Ex010004_1_System_out_println</a><br><br>

            - Java에도 printf() 함수가 있습니다.(format 메서드로 바꿔도 동일한 동작이 가능합니다.) <br>
              public PrintStream printf(String format, Object... args); <br>
              원래는 println()만 있다가 나중에 추가된 메서드입니다. <br>
              C의 printf()처럼 서식지정이 가능합니다. <br>
              이는, 문자열 + 연산을 하지 않기 때문에 성능상 println() 보다 좀 더 우위에 있다고 볼 수 있습니다. <br><br>

            - Object...은 C에서 배운 가변인자와 비슷합니다. <br>
              &#60자료형&#62... &#60매개변수명&#62<br>
              해당 자료형의 데이터만 인자로 전달 가능하나, Object라는 자료형을 쓸 경우 모든 자료형을 넣을 수 있어집니다. <br>
              Object 자료형은 모든 자료형의 부모라고 생각하시면 됩니다. 자세하게는 뒤에서 배우게 됩니다. <br><br>

            <a href="">- Ex01004_2_System_out_printf</a><br><br>

        </p>
        <h4>1.0-5 올바른 새 줄 문자 추가 방법</h4>
        <p>
            - 플랫폼에 따라, 새 줄 문자가 다를 때가 있습니다. <br>
              Linux의 경우에는 '\n'이고, Windows의 경우에는 '\r\n'입니다. <br><br>

            - public static String lineSeparator(); <br>
              lineSeparator() 메서드는 플랫폼에 알맞은 새 줄 문자를 반환해 주는 메서드입니다. <br><br>

            <a href="">- Ex010005_lineSeparator</a><br><br>

        </p>
        <h4>1.0-6 package</h4>
        <p>
            - package &#60패키지경로&#62&#59 <br>
              연관된 클래스들끼리 묶는 기법입니다.(C에서는 없는 개념입니다.) <br>
              마치 폴더와 같은 역할을 합니다.(Java는 package가 folder이기도 합니다.) <br>
              ex. 음악 파일은 음악 폴더에 저장하듯이, 음악 클래스들은 음악 패키지에 정의합니다. <br><br>

            - 패키지의 종류에는 두 가지가 있습니다. <br>
              자바 기본(Built-in) 패키지(java로 시작하는 패키지들. Java가 제공하는 패키지들입니다.) <br>
              ex. java.lang, java.util, ... <br>
              혹은 프로그래머가 직접 만든(user-defined) 패키지들이 있습니다. <br><br>

            - 패키지의 목적은 이름 충돌 문제를 피하게끔 하는 것입니다. <br>
              ex. 마치 monster라는 음악 파일이 있는데, 그 가사를 적은 monster라는 텍스트 파일이 충돌나지 않게끔 서로 다른 폴더에 넣는 것입니다. <br>
                  패키지를 이용하면 java.lang 패키지에도 Math라는 클래스가 있고, academy.codechosun 클래스에도 Math라는 클래스를 만들 수 있습니다. <br><br>
        
            - 패키지의 이름은 중복을 최소화 해야 합니다. <br>
              그래서 보통 회사의 도메인명(Java가 닷컴 버블때 흥해서..)을 패키지 이름에 자주 사용합니다. <br>
              단, 역순으로 적는 것이 관례입니다. <br><br>

        </p>
        <h4>1.0-7 주의: package 이름만 적으면 안됩니다.</h4>
        <p>
            - Java는 package 이름과 실제 .java 파일이 들어있는 폴더구조가 일치해야 합니다. <br>
              따라서 이름만 적으면 에러가 납니다. 그래서 이런 귀찮음을 덜기위해 IDE를 쓰는 경우가 많습니다. <br><br>

            <table>
                <caption>folder tree and package</caption>
                <tbody>
                    <tr>
                        <td></td>
                        <td colspan="2">Ex010005_lineSeparator</td>
                        <td>프로젝트 최상위 폴더</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td colspan="2">src</td>
                        <td>모든 .java 파일이 들어가는 폴더</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td colspan="2">academy</td>
                        <td rowspan="2">최상위 패키지</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td colspan="2">codechosun</td>
                    </tr>
                    <tr>
                        <td>또 다른 하위 패키지</td>
                        <td>&#60패키지명&#62</td>
                        <td>LineSeparator.java</td>
                        <td>main 함수가 있는 .java 파일</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>*.java</td>
                        <td></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </p>
        <h4>1.0-8 커맨드 라인에서 컴파일 하기</h4>
        <p>
            - 아래 코드를 작성 한 후에, Ex010008_class_folder 라는 폴더 바로 아래에 class 폴더를 추가해 봅시다. <br>
              이 class 폴더에 .java 파일이 컴파일 된 결과가 들어갈 예정입니다. <br><br>

            <a href="">- Ex010008_class_folder</a><br><br>

            - cmd 창을 열고, cd 명령어를 이용해서 Ex010008_class_folder로 이동합니다. 그리곤 아래 명령어를 실행시킵니다. <br>
              javac -d class\ src\academy\codechosun\*.java <br><br>

            - javac -d &#60컴파일 결과물(.class)을 저장할 경로&#62 &#60컴파일할 .java 파일명&#62 <br>
              javac는 java compile의 약어입니다. <br>
              옵션인 -d는 directory(folder 개념과 유사)의 약어입니다. .class 파일을 저장할 경로를 지정합니다. <br>
              이 명령어를 실행한 후에는 .java 파일과 .class 파일은 동일한 폴더 구조를 따르게 됩니다. <br><br>

            - 이제 class 폴더를 열어 봅시다. <br>
              컴파일된 .java 클래스의 패키지 이름과 동일한 폴더들이 class 폴더 밑에도 생성 되어 있습니다. <br>
              그리고 그 안에 HelloWorld.class라는 파일이 생성되어 있습니다. <br>
              이 .class 파일에는 바이트 코드가 들어 있습니다. <br>
              Java에서 compile한 결과물은 .exe가 아니라, byte code라는 것을 기억 해 주세요. <br><br>

        </p>
        <h4>1.0-9 프로그램 실행하기</h4>
        <p>
            - 이제는 실행 해 봅시다. 아래 명령어를 cmd에서 실행시켜 봅시다.(이 명령어는 절대경로를 지정하기 때문에, 어떤 폴더에서도 실행 가능합니다.) <br>
              java -classpath &#60절대경로&#62 Ex010008_class_folder.src.academy.codechosun.Helloworld <br><br>

            - java -classpath &#60class 파일의 절대경로&#62 &#60패키지명.클래스명&#62 <br>
              위 명령어는 .class file에 적힌 바이트 코드를 실행하는 명령어입니다. <br>
              해당 클래스에는 반드시 main() 함수가 있어야만 합니다. <br><br>

            - 패키지명을 누락하는 실수가 많습니다. 주의하시기 바랍니다. <br><br>

        </p>
        <h4>1.0-10 배포하기</h4>
        <p>
            - Java의 경우, 라이브러리든 프로그램이든 .jar 파일로 만들어서 배포하게 됩니다. <br><br>
            
            - 똑같이 .jar 파일을 저장하기 위한 lib 폴더를 Ex010010_release 폴더 밑에 만들어 봅시다. <br>
              그리곤, cmd 창에서 cd 명령어를 이용하여 class 폴더로 이동합니다. <br>
              이동 후에는 jar -cf ..\lib\helloworld.jar academy 라는 명령어를 실행 해 봅시다. <br><br>

            - jar &#60option&#62 &#60jar 파일 이름&#62 &#60최상위 패키지 경로&#62 <br>
              .jar 파일을 만드는 명령어입니다. <br>
              옵션으로 -cf를 적었는데, c는 create, f는 만들어질 .jar파일의 이름을 지정하는 것입니다. f 뒤에 파일명이 와야합니다. <br><br>

            - 다만, .jar파일은 단순히 .zip 파일에 지나지 않습니다. <br>
              실제로 알집으로도 압축을 풀 수 있습니다. <br><br>

            <a href="">- Ex010010_jar_file</a><br><br>

            - java -jar helloworld.jar 명령어를 실행해서, jar파일을 실행해 봅시다. <br><br>

        </p>
        <h4>1.0-11 META-INF 폴더와 Manifest 파일</h4>
        <p>
            - 실행 해 보시면 아시겠지만, Manifest 파일이 없다고 나옵니다. <br><br>

            - helloworld.jar 파일을 알집으로 여셔서 보시면, META-INF 폴더가 보입니다. <br>
              이 폴더 안에 manifest 파일이 있습니다. .jar 파일을 만들 때 같이 생성되는 파일입니다. <br><br>

            - Manifest 파일이란 자바 애플리케이션의 정보를 담고 있는 메타데이터 파일입니다. <br>
              .jar 파일을 만들 때 이 파일을 같이 넣어줄 수 있습니다. <br>
              해당 .jar 파일의 entry point인 main() 함수에 대한 정보를 넣어줘야합니다. <br>
              그 밖에도 여러 정보를 담을 수도 있긴합니다. <br><br>

            <a href="">- Ex010011_Manifest</a><br><br>

            - jar -cfm ..\lib\manifest.jar ..\src\Manifest.txt academy 라는 명령어를 실행 해 봅시다. <br>
              추가된 옵션은 -m은 .jar 파일을 만들 때 manifest 파일도 넣겠다는 뜻입니다. <br><br>

            - 실행 하셨다면, java -jar manifest.jar 명령어도 실행해서 잘 나오는지 확인해 봅시다. <br><br>

        </p>
        <h4>1.0-12 외부 패키지 안에 들어있는 클래스 사용하기</h4>
        <p>
            <a href="">- Ex010012_import</a><br><br>

            - 외부 패키지 안에 특정 클래스 사용하기: import &#60패키지명&#62.&#60클래스명&#62&#59 <br>
              외부 패키지 안에 모든 클래스 사용하기: import &#60패키지명&#62.*&#59 <br>
              성능상의 문제는 없지만, 가독성을 위해서 첫 번째 방식으로 적으시는게 올바른 작성법입니다. <br><br>

            - import는 C에서의 #include와 같은 존재입니다. <br><br>

        </p>
        <h4>1.0-13 java.lang</h4>
        <p>
            - Java가 제공해 주는 Built-in package로, 가장 기본이 되는 패키지입니다. <br><br>

            - 모든 .java 파일에 자동으로 import되는 package입니다. <br>
              즉, 사실상 import java.lang.*&#59 라는 코드가 모든 .java 파일에 자동으로 들어간다고 보면 됩니다. <br><br>

            - 우리가 System 클래스를 쓸 수 있었던 이유도, System이 java.lang 안에 있는 클래스 중 하나기 때문입니다. <br><br>

        </p>


        <h2>1.1 실행 모델</h2>
        <h4>1.1-0 Java는 크로스 플랫폼일까요?</h4>
        <p>
            - 자바의 장점으로 항상 언급되는 부분인 크로스 플랫폼(cross-platform)은 <br>
              특정 언어로 작성한 코드를 여러 플랫폼에서 실행할 수 있다는 의미입니다. <br>
              즉, 여러 디바이스와 운영체제에서 실행가능한 소프트웨어를 말합니다. <br><br>

            - Java는 크로스 플랫폼이면서도 아닙니다. 이 말 뜻을 이해하려면 컴파일 및 실행 과정을 살펴보아야 합니다. <br><br>

        </p>
        <h4>1.1-1 C언어의 컴파일 방식 및 실행</h4>
        <p>
            - 소스 코드(.h and .c) ----> <b>전처리기</b>  ----> 확장된 소스 코드(Translation Unit) <br><br>

            - 확장된 소스 코드(Translation Unit) ----> <b>컴파일러</b> ----> 어셈블리 코드(.s) <br><br>

            - 어셈블리 코드(.s) ----> <b>어셈블러</b> ----> 오브젝트 코드(.o) <br><br>

            - 오브젝트 코드(.o) ----> <b>링커</b> ----> 머신 코드(실행파일 or .exe or .out) <br><br>

            - 컴파일 혹은 빌드를 하면 실행 파일이 나옵니다. <br>
              실행 파일은 기계어이며, 운영체제가 직접 실행할 수 있는 파일입니다. <br>
              각 운영체제/디바이스마다 실행파일을 따로 만들어야합니다. <br>
              컴파일러가 소스 코드를 각 운영체제/디바이스에 맞는 기계어로 바꿔주기 때문입니다. <br>
              그래서, C로 작성된 소스 코드는 크로스 플랫폼입니다. 다만 컴파일러를 거친 뒤부터는 크로스 플랫폼이 아닙니다. <br><br>

        </p>
        <h4>1.1-2 Java의 컴파일 방식</h4>
        <p>
            - 소스 코드를 컴파일 혹은 빌드한 결과가 실행 파일이 아닌 바이트 코드입니다. <br><br>

            - 바이트 코드(Byte Code)란, 어떤 운영체제/디바이스가 이해하는 기계어가 아닙니다. <br>
              JVM(Java Virtual Machine)이라는 특수한 프로그램이 이해하는 명령어입니다. <br>
              JVM은 실행 중에 최종 플랫폼에 맞는 기계어로 바꿔서 실행해 줍니다. <br>
              즉, 바이트 코드는 JVM에 맞게 최적화 되어있지만 당연히 기계어보다는 느립니다. <br><br>

        </p>
        <h4>1.1-3 Java 가상 머신(Java Virtual Machine, JVM)</h4>
        <p>
            - JVM은 운영체제에 설치하는 별도의 프로그램입니다. <br>
              각 운영체제/디바이스마다 다른 버전을 설치해야합니다. <br><br>

            - Java로 바이트 코드를 실행합니다. <br>
              즉, Java로 작성된 바이트 코드는 운영체제나 디바이스의 영향을 받지 않습니다. <br>
              이런 면에서는 크로스 플랫폼이라고 할 수 있습니다. <br><br>
              
        </p>
        <h4>1.1-4 Java의 플랫폼은 JVM인건가요?</h4>
        <p>
            - JVM이 설치 안 되어 있다면 어떻게해야 할까요? <br>
              바이트 코드는 당연히 실행 불가능합니다. <br>
              따라서 Java의 플랫폼은 JVM이라고 할 수 있습니다. <br>
              이런 관점에서 보면 크로스 플랫폼이라는 말에는 어폐가 있습니다. <br><br>

            - JVM이 바이트 코드를 실제 디바이스에서 실행하는 방식은 버전에 따라 다양합니다. <br>
              과거 JVM은 인터프리터 방식으로 동작했고, 최신 JVM은 JIT(Just-In-Time) 컴파일이 추가되었습니다. <br>
              여러 가지 컴파일 방식이 공존하며, 이는 JVM 구현자 마음이라는 것입니다. <br><br>

        </p>
        <h4>1.1-5 Java가 인기를 끈 진짜 이유: Java applet</h4>
        <p>
            - 웹 브라우저 안에서 실행 가능한 작은 Java 프로그램을 말합니다. <br><br>

            - 배포 및 실행 절차는 아래와 같습니다. <br>
              첫 번째로, 프로그래머가 코드 패키지를 웹에 업로드 해 둡니다. <br>
              두 번째로, JVM을 갖고 있는 사용자가 웹 브라우저를 통해 이 페이지를 방문합니다. <br>
              세 번째로, 사용자의 웹 브라우저가 이 패키지를 다운로드 후 JVM을 이용해 실행합니다. <br><br>

        </p>
        <h4>1.1-6 Java applet의 장점</h4>
        <p>
            - 데스크탑 수준의 기능을 웹에서 실행 가능하게 했던 거의 유일한 플랫폼이었습니다. <br>
              이 당시에는 인터넷이 대중화 되기 시작하던 시점입니다. <br>
              근데 당시 웹 브라우저의 기능은 그저 정적인 문서를 보여주는 정도에 그쳤습니다. <br><br>

            - Java applet 덕분에 미래에 새로운 플랫폼이 나오더라도 다시 컴파일 하지 않아도 됬습니다. <br><br>

        </p>
        <h4>1.1-7 Java applet의 현모습</h4>
        <p>
            - 최신 웹 브라우저들은 Java applet을 더이상 지원하지 않습니다. <br>
              이제는 웹 표준만으로도 그런 기능들을 구현할 수 있기 때문입니다. <br>
              JS, WASM 등으로 작성한 웹 어플리케이션이 Java applet을 대체해 버렸습니다. <br><br>

            - 참고로 서버에서 실행되는 비슷한 개념의 프로그램은 아직 존재합니다. <br>
              ex. servlet <br><br>
              
        </p>

        <h2>1.2 구조적 프로그래밍 요소</h2>
        <h4>1.2-0 구조적(Structured) 프로그래밍 요소</h4>
        <p></p>
        <h4>1.2-1 자료형</h4>
        <p></p>
        <h4>1.2-2 부호 있는 자료형만 존재</h4>
        <p></p>
        <h4>1.2-3 부호 없는 자료형 부재의 단점들</h4>
        <p></p>
        <h4>1.2-4 boolean</h4>
        <p></p>
        <h4>1.2-5 기본 자료형은 모두 "값형"입니다.</h4>
        <p></p>
        <h4>1.2-6 String</h4>
        <p></p>
        <h4>1.2-7 String과 new 키워드</h4>
        <p></p>
        <h4>1.2-8 Java의 String은 변경 불가(immutable)입니다.</h4>
        <p></p>
        <h4>1.2-9 정수 literal</h4>
        <p></p>
        <h4>1.2-10 부동소수점 literal</h4>
        <p></p>
        <h4>1.2-11 문자/문자열 literal</h4>
        <p></p>
        <h4>1.2-12 기타 literal</h4>
        <p></p>
        <h4>1.2-13 Java의 상수형 변수: final 키워드</h4>
        <p></p>
        <h4>1.2-14 final 키워드를 붙일 수 있는 곳</h4>
        <p></p>
        <h4>1.2-15 final과 멤버 변수</h4>
        <p></p>
        <h4>1.2-16 final과 메서드</h4>
        <p></p>
        <h4>1.2-17 final 변수의 초기화 1: 선언과 동시에</h4>
        <p></p>
        <h4>1.2-18 final 변수의 초기화 2: 사용하기 전에만</h4>
        <p></p>
        <h4>1.2-19 final 변수의 초기화 예</h4>
        <p></p>
        <h4>1.2-20 주석</h4>
        <p></p>
        <h4>1.2-21 Javadoc 주석 예</h4>
        <p></p>
        <h4>1.2-22 Javadoc 주석: /** */</h4>
        <p></p>
        <h4>1.2-23 Javadoc 주석: @&#60태그&#62</h4>
        <p></p>
        <h4>1.2-24 연산자 우선순위</h4>
        <p></p>
        <h4>1.2-25 산술 연산자</h4>
        <p></p>
        <h4>1.2-26 대입 연산자</h4>
        <p></p>
        <h4>1.2-27 값형과 대입 연산자 =</h4>
        <p></p>
        <h4>1.2-28 참조형과 대입 연산자 =</h4>
        <p></p>
        <h4>1.2-29 String과 대입 연산자</h4>
        <p></p>
        <h4>1.2-30 문자열과 대입 연산자</h4>
        <p></p>
        <h4>1.2-31 자료형 반환</h4>
        <p></p>
        <h4>1.2-32 논리 연산자</h4>
        <p></p>
        <h4>1.2-33 == 연산자와 문자열</h4>
        <p></p>
        <h4>1.2-34 문자열은 참조형</h4>
        <p></p>
        <h4>1.2-35 허나 주소를 공유하는 경우가 있습니다.</h4>
        <p></p>
        <h4>1.2-36 equals() 메서드</h4>
        <p></p>
        <h4>1.2-37 연산자 오버로딩</h4>
        <p></p>
        <h4>1.2-38 문자열과 + 및 += 연산자</h4>
        <p></p>
        <h4>1.2-39 Java의 문자열 비교 베스트 프랙티스</h4>
        <p></p>
        <h4>1.2-40 비트 이동(bit shift) 연산자</h4>
        <p></p>
        <h4>1.2-41 >>></h4>
        <p></p>
        <h4>1.2-42 if문</h4>
        <p></p>
        <h4>1.2-43 switch/case 문</h4>
        <p></p>
        <h4>1.2-44 case에 사용 가능한 자료형</h4>
        <p></p>
        <h4>1.2-45 case 안에서 break 생략</h4>
        <p></p>
        <h4>1.2-46 Java와 C#의 차이</h4>
        <p></p>
        <h4>1.2-47 for 문 및 while 문</h4>
        <p></p>
        <h4>1.2-48 continue, break, goto</h4>
        <p></p>
        <h4>1.2-49 goto문을 사용하면 좋은 경우</h4>
        <p></p>
        <h4>1.2-50 goto문 같은것: break &#60라벨 이름&#62</h4>
        <p></p>
        <h4>1.2-51 break와 레이블</h4>
        <p></p>
        <h4>1.2-52 goto와는 다릅니다.</h4>
        <p></p>
        <h4>1.2-53 continue 역시 라벨을 사용할 수 있습니다.</h4>
        <p></p>
        <h4>1.2-54 foreach 스타일 for 문</h4>
        <p></p>
        <h4>1.2-55 함수</h4>
        <p></p>
        <h4>1.2-56 add() 함수 호출 후 v1의 값은?</h4>
        <p></p>
        <h4>1.2-57 함수 호출과 참조형 인자</h4>
        <p></p>
        <h4>1.2-58 add() 함수의 매개변수에 final 붙이기</h4>
        <p></p>
        <h4>1.2-59 final 참조형 매개변수</h4>
        <p></p>
        <h4>1.2-60 1차원 배열</h4>
        <p></p>
        <h4>1.2-61 다차원 배열</h4>
        <p></p>
        <h4>1.2-62 Java의 열거형</h4>
        <p></p>
        <h4>1.2-63 Java의 열거형에서 못하는 것들</h4>
        <p></p>
        <h4>1.2-64 Java의 열거형은 클래스형</h4>
        <p></p>
        <h4>1.2-65 열거형 예</h4>
        <p></p>
        <h4>1.2-66 열거형과 생성자</h4>
        <p></p>
        <h4>1.2-67 열거형과 new 키워드</h4>
        <p></p>
        <h4>1.2-68 var</h4>
        <p></p>
        <h4>1.2-69 Java에는 LINQ가 없나요?</h4>
        <p></p>
        <h4>1.2-70 람다 표현식(lambda expression)</h4>
        <p></p>

        <h2>1.3 모듈</h2>
        <h4>1.3-0 기본 방식: Package</h4>
        <p></p>
        <h4>1.3-1 기본 패키지 시스템의 한계</h4>
        <p></p>
        <h4>1.3-2 새로운 방식: Module</h4>
        <p></p>
        <h4>1.3-3 Module</h4>
        <p></p>
        <h4>1.3-4 Module의 이름</h4>
        <p></p>
        <h4>1.3-5 module-info.java</h4>
        <p></p>
        <h4>1.3-6 지금은 크게 중요한 내용이 아닙니다.</h4>
        <p></p>


    </body>
</html>