<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>OOP Chapter 04. Object Modeling</title>
    
        <link rel="stylesheet" href="../font/font.css">
    
    </head>
    <body>
        <h1>Chapter 04. 개체 모델링</h1>
        <h2>4.0 클래스 다이어그램</h2>
        <h4>4.0-0 시작하기 전에</h4>
        <p>
            - 클래스 작성에 필요한 문법을 배워보았으니, 이를 활용해서 실제로 만들어 봅시다. <br>
              실존하는 물체의 상태와 동작 그리고 물체 간의 상호작용을 만들어 보겠습니다. <br>
              물론 클래스를 이용해서 만들어 볼 예정입니다. 막막하지만, 막막한 것이 당연한 것입니다. 개체지향에는 정답이 없기 때문입니다. <br><br>

            - OO 설계에서 처음 맞닥트리는 난관입니다. <br>
              이렇다 할 정답이 없습니다. 사람처럼 생각하자는 것이 OOP인데, 사람다움은 주관적이기 때문입니다. <br>
              그래서 한 번에 제대로 설계하기도 어렵습니다. 여러 번 고치는 것이 당연한 것입니다. <br><br>

            - 이제부터 개체를 설계하는 다양한 방법을 볼 예정입니다. <br>
              그런데, 주관적이라 여러 경우의 수가 있습니다. 즉 코드의 경우의 수가 너무 많은 것이죠. <br>
              경우의 수를 일일이 보기 힘드므로 유용한 도구를 하나 배워보도록 하겠습니다. <br><br>

        </p>
        <h4>4.0-1 클래스 다이어그램(Class Diagram)</h4>
        <p>
            - 어떤 시스템에 있는 클래스들을 보여주는 다이어그램입니다. <br>
              클래스 안에 들어있는 상태, 동작, 접근 제어자를 보여줍니다. <br>
              또한, 클래스 간의 관계(상속, 컴포지션 등)도 보여줍니다. <br><br>

            - 시스템의 정적인 구조를 보여주기에 적합합니다. <br>
              먼 훗날 데이터베이스 설계할 때도 비슷한 다이어그램을 볼 것입니다. <br>
              클래스 다이어그램은 UML(Unified Modeling Language)의 일부입니다. <br><br>

        </p>
        <h4>4.0-2 UML이란</h4>
        <p>
            - 시스템의 디자인을 시각화하기 위해 만든 표준입니다. <br>
              만약 UML이 없다면 공통된 규칙이 없기 때문에 중구난방이 되기 쉽습니다. <br><br>

            - UML의 종류에는 크게 두 종류로 나뉩니다. <br>
              구조를 보여주는 다이어그램 7개(대표: 클래스 다이어그램) <br>
              동작을 보여주는 다이어그램 7개(대표: 시퀀스 다이어그램) <br><br>

            - UML이 유행하던 시절이 있었습니다. <br>
              한 때 OO 설계를 한다고 하면 UML부터 배우던 시절이 있긴 있었습니다. <br>
              그러나 이제는 세상이 바뀌었습니다. IDE에 자체 내장되어 있던 UML 그리기 툴도 빠지고 있는 상황입니다. <br>
              이 과정에서는 2개 정도만 볼 예정입니다. 그 외는 거의 볼 일도 없고, 보게 되면 그때 검색해서 이해해도 충분합니다. <br><br>

        </p>
        <h4>4.0-3 참고: OO에서 공통의 용어를 쓰자는 움직임</h4>
        <p>
            - OO에서 공통의 용어를 쓰자는 움직임이 크게 둘이 있었습니다. 둘 다 비슷한 시기인 90년대 중반에 나왔습니다. <br>
              UML: OO 설계를 시각화하는 방법의 표준화를 추구합니다. <br>
              디자인 패턴: OO 설계를 이용한 문제 해결법의 표준화를 추구합니다. <br><br>

            - 둘 다 열심히 가르쳤지만 효과는 미미했습니다. <br>
              명목은 소프트웨어 품질의 향상("이것만"하면 품질향상이라는 주장)이었지만, 결과적으론 효과가 별로 없었습니다. <br>
              UML은 이제 거의 안쓰이고, 디자인패턴은 주니어 개발자가 패턴을 잘못 적용하는 경우가 빈번했습니다. <br><br>

            - 이제는 Stack Overflow의 시대입니다. 문제에 직면했는데, 해결법을 모르겠다면 전 세계의 프로그래머들에게 의견을 묻고 답을 구할 수 있습니다. <br>
              또 대부분의 경우 이미 여기에 답이 있기도 합니다. <br><br>

        </p>
        <h4>4.0-5 Dog과 Human 클래스</h4>
        <p>
            <a href="">- Ex040005_DogAndHumanClass</a><br><br>
        </p>
        <h4>4.0-6 클래스 다이어그램: 클래스명</h4>
        <p>
            <table class="ClassDiagram">
                <tbody>
                  <tr>
                    <td>Human</td>
                  </tr>
                  <tr>
                    <td></td>
                  </tr>
                  <tr>
                    <td></td>
                  </tr>
                </tbody>
            </table>
            <br><br>

            <table>
              <tbody>
                <tr>
                  <td>Dog</td>
                </tr>
                <tr>
                  <td></td>
                </tr>
                <tr>
                  <td></td>
                </tr>
              </tbody>
            </table>


        </p>
        <h4>4.0-7 클래스 다이어그램: 멤버 변수</h4>
        <p>
          <table>
            <tbody>
              <tr>
                <td>Human</td>
              </tr>
              <tr>
                <td>
                  -name: String <br>
                  -age: int <br>
                  -puppy: Dog <br>
                </td>
              </tr>
              <tr>
                <td></td>
              </tr>
            </tbody>
        </table>
        <br><br>

        <table>
          <tbody>
            <tr>
              <td>Dog</td>
            </tr>
            <tr>
              <td>
                ~happiness: float <br>
              </td>
            </tr>
            <tr>
              <td></td>
            </tr>
          </tbody>
        </table>
        </p>
        <h4>4.0-8 클래스 다이어그램: 메서드</h4>
        <p>
          <table>
            <tbody>
              <tr>
                <td>Human</td>
              </tr>
              <tr>
                <td>
                  -name: String <br>
                  -age: int <br>
                  -puppy: Dog <br>
                </td>
              </tr>
              <tr>
                <td>
                  +Human(String, int) <br>
                  +getName(): String <br>
                  +setName(String) <br>
                  +pat(Dog) <br>
                </td>
              </tr>
            </tbody>
        </table>
        <br><br>

        <table>
          <tbody>
            <tr>
              <td>Dog</td>
            </tr>
            <tr>
              <td>
                ~happiness: float <br>
              </td>
            </tr>
            <tr>
              <td>

              </td>
            </tr>
          </tbody>
        </table>
        </p>
        <h4>4.0-9 클래스 다이어그램: 접근 제어자</h4>
        <p>
            <table>
              <thead>
                <tr>
                  <td>기호</td>
                  <td>접근제어자</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>+</td>
                  <td>public</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>private</td>
                </tr>
                <tr>
                  <td>~</td>
                  <td>default/package</td>
                </tr>
              </tbody>
            </table>
        </p>
        <h4>4.0-10 클래스 다이어그램: 의존 관계(dependency)</h4>
        <p>
            - 아주 많이 사용하진 않습니다. <br>
              Human 클래스의 pat() 메서드가 인자로 Dog 클래스를 필요로 하기 때문에 "Human이 Dog에 의존한다."고 볼 수 있습니다. <br><br>
              
            - 클래스들 간의 관계를 보여주는 다른 선들도 차차 공부 해 봅시다. <br><br>

            <table>
              <thead>
                <tr>
                  <td>기호</td>
                  <td>클래스들 간의 관계</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>----></td>
                  <td>의존관계</td>
                </tr>
              </tbody>
            </table>

        </p>

        <h2>4.1 클래스 설계 방법</h2>
        <h4>4.1-0 만들어 볼 간단한 시스템: 꽃에 물주기</h4>
        <p>
          - 이 꽃은 일정량의 물을 매일 뿌려만 주면 평생을 삽니다. <br><br>
          
          - 물을 뿌릴 때 사용하는 도구는 분무기입니다. <br><br>

          - 하루라도 필요한 물을 못 받으면 죽습니다. <br><br>

          - 그 뒤에는 아무리 물을 뿌려도 안 살아납니다. <br><br>

        </p>
        <h4>4.1-1 1단계: 분무기 모델링</h4>
        <p>
          - 먼저 클래스명부터 정해봅시다. <br>
            ex. WaterSpray <br><br>

          - 그 다음은 멤버변수입니다. <br>
            분무기의 가장 중요한 상태는 현재 남아있는 물의 양입니다. <br>
            처음 분무기가 생성될 때는 당연히 0입니다. <br>
            ex. private int remainingWaterInMl = 0<br><br>

          - 그 다음으로는 메서드입니다. <br>
            당연히 생성자가 필요할 것입니다. <br>
            그리고 남은 물의 양을 확인할 수 있으면 좋으니 getter도 추가합시다. <br>
            물이 떨어지면 다시 채워야 하니까 setter도 추가합니다. <br><br>

          <a href="">- Ex040101_WaterSpray_Ver1</a><br><br>

          - 물을 채울 때 어떻게 생각하시나요? <br>
            200ml까지 채워야지 Vs. 100ml만큼 추가해야지 <br><br>

          - 정답은 없습니다. 주관적인 부분입니다. 원한다면 두 메서드 모두 추가해도 됩니다만, 후자로 가보도록 하겠습니다. <br>
            "100ml만큼 추가해야지"로 간다면 메서드 구현을 아래와 같이 바꿔야 적합합니다. <br>
            public void addWater(int amountInMl) { <br>
              this.remainingWaterInMl += amountInMl; <br>
            } <br><br>

        </p>
        <h4>4.1-2 2단계: 물 뿌리기</h4>
        <p>
          - 물 뿌리기 동작을 만들려고 합니다. 메서드의 이름을 어떻게 지어야할까요. <br>
            역시 다양한 선택지가 존재합니다. 예로 들어보겠습니다. <br><br>

          - 동작에 초첨을 맞출 경우 <br>
            pull(): 방아쇠를 당기다.(pull the trigger) <br>
            press(): 펌프를 누르다.(press the pump) <br><br>

          - 용도에 초점을 맞출 경우 <br>
            spray(): 뿌리다.(이 이름으로 짓겠습니다.) <br><br>

          <a href="">- Ex040102_WaterSpray_Ver2</a><br><br>

        </p>
        <h4>4.1-3 void spray() Vs. int spray()</h4>
        <p>
            - 또다시 생기는 고민이 있습니다. <br>
              분무한 양을 반환하지 말지, 반환할지에 관한 결정입니다. <br><br>

            - 분무한 양을 반환하지 않더라도, 아래와 같은 코드로 확인 가능합니다. <br>
              int beforeMl = waterSpray.getRemainingWater(); <br>
              waterSpray.spray(); <br>
              int spreayedMl = beforeMl - waterSpray.getRemainingWater(); <br><br>

            - 혹은 분무한 양을 계산해서 spray() 메서드가 반환하게끔 만들 수도 있습니다. <br>
              public int spray() { <br>
                int sprayedMl = Math.min(this.remainingWaterInMl, 5); <br>
                this.remainingWaterInMl -= sprayedMl; <br><br>

                return sprayedMl; <br><br>

              } <br><br>

            - 물론 또 정답은 없지만, 두 번째 방법에는 약간의 문제가 있습니다. <br><br>

            - 메서드 시그네처만으로 정확히 뭘 반환하는지 알기 힘듭니다. <br>
              물론 메서드명을 int sprayAndGetUsedAmount() {}라고 명시하는 것도 하나의 방법입니다. <br><br>

            - 메서드가 하는 일이 너무 많다고 볼 수도 있습니다. <br>
              이것 또한 주관적인 관점입니다. 하지만 뭐든 명백한 것이 좋기 때문에 void spray()가 좀 더 좋다고 생각합니다. <br>
              다만 두 번째 방법도 흔히 사용하는 패턴이긴 합니다. <br><br>

        </p>
        <h4>4.1-6 개체 모델링에서 흔히 저지르는 실수</h4>
        <p>
            - 분무기도 색상/모양/제조사가 다양하지 않나요? <br>
              이것도 반영해서 클래스 다이어그램을 작성해야 하지 않을까요? <br>
              맞는 이야기지만, 반드시 필요한 정보인지를 알아야 합니다. <br><br>

            - 실세계의 상태와 동작을 모두 클래스에 넣으려고 하지 맙시다. <br>
              일단 작성한 코드는 유지보수의 대상이 되기 때문입니다. <br>
              개발하다 보면 코드를 여러 번 고치게 됩니다. <br>
              이때 사용하지도 않는 멤버 변수, 메서드가 있다해도 계속 고치고 테스트 해야만 합니다. <br>
              즉, 쓸데 없는 유지보수 비용이 증가하게 됩니다. <br><br>

            - 처음부터 올바르게 모델링 할 수 있다는 망상을 버려야 합니다. <br>
              사람은 점진적으로 배워가는 동물입니다. 코드는 필요한 시점에 추가하면 됩니다. <br>
              TMI는 오히려 독이 됩니다. <br><br>
              
        </p>
        <h4>4.1-7 3단계: 분무기의 최대 용량</h4>
        <p>
            - 현재 우리가 설계한 WaterSpray 클래스에는 최대 용량이 없습니다. <br>
              즉, addWater()를 계속 호출하면 끝도 없이 물통이 커집니다. <br>
              분무기의 최대 용량을 추가하려면 어떻게 해야 할까요? 두 가지 방법이 있습니다. <br><br>

            - 모든 분무기의 용량이 같은 경우 <br><br>

            <a href="">- Ex040107_1_WaterSpray_Ver3</a><br><br>

            - 클래스 다이어그램의 범위 <br>
              클래스가 가지고 있는 상태(멤버 변수) <br>
              클래스에 실행할 수 있는 동작의 목록 <br>
              클래스 간의 관계 <br><br>

            - 상수는 상태에 속하지 않습니다. 이 상수는 내부 구현에서 어떻게 사용하는지도 관심 밖입니다. <br>
              따라서 위 예제의 클래스 다이어그램도 변하지 않습니다. <br><br>

            - 다만 분무기의 용량이 달라질 수 있는 경우에는 클래스 다이어그램도 수정되어야 합니다. <br>
              일단 공장에서 찍어 나오면 그 뒤에 용량은 바뀌지 않는다고 가정합시다. <br>
              따라서 생성자에서 초기화되고 변경 불가능한 멤버 변수가 필요하고, 이 변수는 setter가 없어야 합니다. <br><br>

            <table>
              <thead>
                <tr>
                  <td><b>WaterSpray</b></td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    -capacity: int <br>
                    -remainingWaterInMl: int = 0 <br>
                  </td>
                </tr>
                <tr>
                  <td>
                    +WaterSpray(int) <br>
                    +getCapacity(): int <br>
                    +getRemainingWater(): int <br>
                    +addWater(int) <br>
                    +spray() <br>
                  </td>
                </tr>
              </tbody>
            </table>

            <a href="">- Ex040107_2_WaterSpray_Ver4</a><br><br>

        </p>
        <h4>4.1-8 '가득 채워야겠다' 동작 추가하기</h4>
        <p>
            - 이미 반쯤 차 있는 분무기 통에 물을 추가할 때 다들 어떻게 생각하시나요? <br>
              100ml만 더 넣어야지 Vs. 가득 채워야겠다 <br>
              다들 가득 채우려고 하시지 않나요? <br><br>

            - capacity라는 상태가 있으니 충분히 가득 채우는 동작을 구현 가능합니다. <br>
              가득 채운다는 의미에서 fillUp()으로 지어봅시다. <br><br>

            <table>
              <thead>
                <tr>
                  <td><b>WaterSpray</b></td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    -capacity: int <br>
                    -remainingWaterInMl: int = 0 <br>
                  </td>
                </tr>
                <tr>
                  <td>
                    +WaterSpray(int) <br>
                    +getCapacity(): int <br>
                    +getRemainingWater(): int <br>
                    +addWater(int) <br>
                    +fillUp() <br>
                    +spray() <br>
                  </td>
                </tr>
              </tbody>
            </table>

            <a href="">- Ex040108_WaterSpray_Ver5</a><br><br>

            - 예제를 작성 해 보시면 느끼시겠지만, 상태를 추가하면 새로운 메서드도 필요하게 됩니다. <br>
              즉, 필요한 상태만 추가하는게 좋은 또 다른 이유가 됩니다. <br><br>

        </p>
        <h4>4.1-9 4단계: 수도꼭지가 필요하지 않을까요?</h4>
        <p>
            - 분무기에 마법처럼 물을 채울 수 있는게 말이 안되지 않나요? <br>
              물을 받을 수 있는 수도꼭지가 필요하지 않을까요? <br><br>

            - 그럼 어떻게 구현하면 좋을까요? <br>
              수도꼭지(Faucet) 클래스가 있고, 어떤 상태를 가질지는 미지수지만 동작은 분무기에 물을 채우기면 되지 않을까요? <br><br>
        </p>

        <table>
          <thead>
            <tr>
              <td><b>Faucet</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td></td>
            </tr>
            <tr>
              <td>
                +fillUp(WaterSpray) <br>
                +addWaterTo(WaterSpray, int) <br>
              </td>
            </tr>
          </tbody>
        </table><br><br>

        <p>
            - 좋은 시도지만, Faucet 클래스를 추가하는 것은 문제가 있습니다. <br><br>
        </p>

        <h4>4.1-10 Faucet 클래스의 문제점</h4>
        <p>
            - 첫 번째, WaterSpray 클래스에는 여전히 addWater()와 같은 public 함수가 필요합니다. <br>
              Faucet 클래스가 WaterSpray 클래스 안에 있는 물의 양을 바꿔줘야 하기 때문입니다. <br>
              물의 양은 private 접근 제어자가 붙어 있기 때문에 그렇습니다. <br>
              때에 따라서는 패키지 접근 제어자로도 가능하긴 합니다. 두 클래스가 같은 패키지에 들어 있다면요. <br>

            - 두 번째, 정말 Faucet 클래스가 필요한지 의구심을 가져야 합니다. <br>
              역시 실세계를 그대로 모델링 하려다 저지르는 실수입니다. <br>
              수도꼭지를 만들면 물은 자동으로 나오나요? 거기에 연결되는 집속 파이프, 송수관, 정화시설, 식수원, ... 끝이 없습니다. <br>
              전세계를 시뮬레이션 할 생각이 아니라면 어디에선가 선을 그어야 합니다. 또 현재 Faucet 클래스는 WaterSpray 클래스 외엔 사용할 데도 없습니다. <br><br>
              
        </p>
        <h4>4.1-11 5단계: 화분</h4>
        <p>
            - 이제 화분을 만들어 봅시다. 클래스명은 FlowerPot이라고 하겠습니다. <br><br>
        </p>

        <table>
              <thead>
                <tr>
                  <td><b>FlowerPot</b></td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td></td>
                </tr>
                <tr>
                  <td></td>
                </tr>
              </tbody>
        </table><br><br>

        <p>
            - 멤버 변수에는 살았는지 죽었는지를 기억할 alive라는 변수가 필요합니다. <br>
              물론 처음에는 살아있으니, 기본값은 true라고 초기화 해 줍시다. <br><br>
            
            - 두 번째 멤버 변수로는 매일 필요한 최소 물의 양을 저장하는 변수가 필요할 것 같습니다. <br>
              또 꽃마다 다른 양이 필요하니 생성자를 통해서 초기화 하는게 좋을 것 같습니다. <br><br>
            
        </p>

        <table>
              <thead>
                <tr>
                  <td><b>FlowerPot</b></td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    -alive: boolean = true <br>
                    -minDailyWaterInMl: int <br>
                  </td>
                </tr>
                <tr>
                  <td>
                  </td>
                </tr>
              </tbody>
        </table><br><br>

        <p>
            - 메서드에는 일단 생성자가 당연히 있어야 겠죠? <br>
              매개변수로는 이 화분의 매일 필요한 최소 물의 양을 전달받습니다. <br><br>
            
            - 살았는지 죽었는지 알아야 하니까 getter도 필요할 것 같습니다.(보통 boolean형의 getter는 is를 많이 씁니다.) <br>
              당연하게도 alive의 setter는 없습니다. 한 번 죽은 꽃은 되살아나지 않기 때문입니다. <br><br>

            - 매일 필요한 최소 물의 양의 getter는 추가해도 큰 문제가 없으니 추가합니다. <br>
              다만 setter는 추가하지 않습니다. <br><br>

            - 화분에 물을 줄 수 있어야 하므로, addWater() 메서드도 필요합니다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>FlowerPot</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -alive: boolean = true <br>
                -minDailyWaterInMl: int <br>
              </td>
            </tr>
            <tr>
              <td>
                +FlowerPot(int) <br>
                +isAlive(): boolean <br>
                +getMinDailyWater(): int <br>
                +addWater(int) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
          <a href="">- Ex040111_FlowerPot_Ver1</a><br><br>
        </p>
        
        <h4>4.1-12 화분에 물주기</h4>
        <p>
            <a href="">- EX040112_SprayToFlowerPot_Ver1</a><br><br>

            - 위 코드의 문제는 두 번 뿌릴 수 없다는 것입니다. <br>
              한 번 뿌리면 하루가 지났다고 가정하기 때문입니다. <br>
              한 번 분무량이 5ml여도 두 번 뿌리면 10ml가 되니까, 이걸 코드에 적용해 봅시다. <br><br>

        </p>
        <h4>4.1-13 하루에 여러 번 뿌릴 수 있게 다시 모델링</h4>
        <p>
            - 이를 모델링하려면 FlowerPot에서 다음을 할 수 있어야 합니다. <br>
              하루에 받은 총 분무량을 기억해야 하고, 하루가 끝났음을 알려야 합니다. <br>
              이를 위해 addWater()도 조금 수정되어야 합니다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>FlowerPot</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -alive: boolean = true
                -minDailyWaterInMl: int
                -dailyReceivedWaterInMl: int = 0
              </td>
            </tr>
            <tr>
              <td>
                +FlowerPot(int) <br>
                +isAlive(): boolean <br>
                +getMinDailyWater(): int <br>
                +getRecievedWater(): int <br>
                +addWater(int) <br>
                +liveAnotherDay() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
            <a href="">- Ex040113_SprayToFlowerPot_Ver2</a><br><br>
        </p>

        <h4>4.1-15 구조체 사고방식에서 벗어나지 못했습니다.</h4>
        <p>
            - 위 예제코드들의 가장 큰 문제는 WaterSpray 클래스 개체와 FlowerPot 클래스 개체들 간에 상호작용이 전혀 없습니다. <br>
              다시 말해, 구조체 사고방식에서 벗어나지 못했습니다. <br><br>

            - 호출자가 직접 아래와 같은 일들을 해줍니다. <br>
              분무기의 남은 양 저장 -> 분무기 분사 -> <br>
              이전에 저장된 분무기 남은양과 분사 후 남은 양을 빼서 분사된 양을 구함 -> 분사된 양을 화분에 추가 <br><br>

            - 즉 WaterSpray 클래스 개체나 FlowerPot 클래스 개체를 그냥 데이터 저장소로만 쓴거나 다름이 없습니다. <br>
              물론 spray() 메서드나 addWater() 메서드에서 데이터 검증은 합니다. <br><br>

            - 클래스 다이어그램으로 보아도 두 클래스 간에 의존관계가 아에 없는 상황입니다. <br>
              즉, 누군가가 이 두 클래스 사이에서 중재해주고 있는 꼴입니다. <br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWaterInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +fillUp() <br>
                +spray() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>FlowerPot</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -alive: boolead = true <br>
                -minDailyWaterInMl: int <br>
                -dailyReceivedWatetInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +FlowerPot(int) <br>
                +isAlive(): boolean <br>
                +getMinDailyWater(): int <br>
                +getRecievedWater(): int <br>
                +addWater(int) <br>
                +liveAnotherDay() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <h4>4.1-16 6단계: 두 클래스가 서로 직접 상호작용 하도록</h4>
        <p>
            - 문제는 다음 두 메서드라고 할 수 있습니다. <br>
              WaterSpray.spray()와 FlowerPot.addWater(int)입니다. <br><br>

            - 두 메서드 모두 너무나 범용적인 자료형인 int를 사용중입니다. <br>
              즉, 누구나 이 함수를 마음대로 호출할 수 있습니다. <br>
              다만 이 방식으로 하는게 언제나 틀린건 아닙니다. <br><br>

            - 클래스 설계를 바꿔서 상호작용할 수 있는 대상을 특정 해 봅시다. 두 가지 방법이 있습니다. <br><br>

        </p>
        <h4>4.1-17 방법1: '분무기를 화분에 대고 뿌린다'</h4>
        <p>
            - 새로운 메서드 sprayTo()를 구현 해 봅시다. <br>
              인자로는 FlowerPot 클래스 개체를 받습니다. <br><br>

            - spray() 메서드는 없어도 됩니다만, 허공에 대고 뿌리면 기분이 좋으니 살려둡시다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWaterInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +fillUp() <br>
                +spray() <br>
                +sprayTo(FlowerPot) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>FlowerPot</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -alive: boolead = true <br>
                -minDailyWaterInMl: int <br>
                -dailyReceivedWatetInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +FlowerPot(int) <br>
                +isAlive(): boolean <br>
                +getMinDailyWater(): int <br>
                +getRecievedWater(): int <br>
                +addWater(int) <br>
                +liveAnotherDay() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
          <a href="">- Ex040117_SprayToFlowerPot_Ver3</a><br><br>

          - 위 예제에서도 보셨겠지만, 덕분에 호출자 코드가 굉장히 간단해 졌습니다. <br><br>

        </p>
        
        <h4>4.1-18 방법2: '분무기를 줄 테니 알아서 뿌리세요'</h4>
        <p>
          - FlowerPot의 addWater()를 변경합니다. <br>
            인자로 WaterSpray를 받습니다. 즉 자신이 알아서 스스로에게 분무기를 뿌립니다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWaterInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +fillUp() <br>
                +spray() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>FlowerPot</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -alive: boolead = true <br>
                -minDailyWaterInMl: int <br>
                -dailyReceivedWatetInMl: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +FlowerPot(int) <br>
                +isAlive(): boolean <br>
                +getMinDailyWater(): int <br>
                +getRecievedWater(): int <br>
                +addWater(WaterSpray) <br>
                +liveAnotherDay() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
          <a href="">- Ex040118_SprayToFlowerPot_Ver4</a><br><br>

        </p>

        <h4>4.1-19 두 방법 중 뭐가 더 좋은가요?</h4>
        <p>
          - 첫 번째, 분무기를 화분에 대고 뿌린다 <br>
            두 번째, 분무기를 줄테니 화분이 알아서 뿌린다 <br><br>

          - 정답은 없습니다만, 우리에게 익숙한 생각은 1번인듯 합니다. <br><br>

          - 하지만, 좀 더 개체지향적인 생각에 가까운 것은 2번입니다. <br>
            FlowerPot.addWater(int)를 제거가능하고, 분무기만 화분에 물을 줄 수 있습니다. <br>
            따라서 2번을 선택해서 진행하겠습니다. <br><br>

        </p>
        <h4>4.1-20 OO는 약간의 사고방식 변화가 필요합니다.</h4>
        <p>
          - 화분은 그냥 물체일 뿐인데, 생명체마냥 혼자서 물을 뿌리는게 너무 어색합니다. <br>
            즉, 실세계의 물체(Object)는 거의 완전히 수동적인 존재입니다. 누군가가 조작해 줘야합니다. <br><br>

          - 그러나 OO 세계의 물체는 어느정도 자기 주관을 가진 주체입니다. <br>
            따라서 객체라는 용어보단, 개체라는 용어가 더 적합합니다. <br>
            심지어 특정 소수설은 완벽한 주체성을 가진 생명체의 개념으로 보려할 정도입니다. <br>
            우리는 그정도까진 아니더라도 실세계보다는 주체성을 가진다고 생각합시다. <br><br>

        </p>
        <h4>4.1-21 완성된 설계</h4>
        <p>
            - 이렇게해서 드디어 완성하였습니다. 이정도면 괜찮은 설계입니다. <br>
              클래스도 2개로 매우 간단합니다. <br>
              나름 복잡한 계산 로직도 클래스 안으로 숨겼습니다. ex. FlowerPot.addWater(WaterSpray); <br>
              클래스가 상호작용할 수 있는 대상도 제한적으로 잘 짜여져 있습니다. <br>
              실무에서도 보통 이정도로 설계하게 됩니다. <br><br>

        </p>

        <h2>4.2 코드의 유연성</h2>
        <h4>4.2-0 다만 유연성은 떨어집니다.</h4>
        <p>
            - 화분에 물을 줄 때 컵을 사용하고 싶다. -&#62 이런 것들은 나중에 추상클래스를 배우면 알게 됩니다. <br><br>

            - 다만 이 예제에서 재활용할 수 있는 부분이 없을지 찾아 봅시다. <br><br>

        </p>
        <h4>4.2-1 7단계: 분무기를 두 부품으로 분리해 봅시다.</h4>
        <p>
            - 실제 분무기는 2개의 부품을 합쳐 놓은 것입니다. <br>
              머리 부분과 몸통부분으로 말입니다. <br><br>

            - 머리에는 손잡이와 호스가 있습니다. <br>
              손잡이를 한 번 꾹 누르면 정해진 만큼의 물이 나갑니다. <br>
              On/Off나 분사 양 조절 기능이 있을 수 있습니다. <br>
              손잡이 모양도 달라질 수 있습니다. <br>
              아무 병에 연결하면 분무 할 수 있습니다. 콜라병에 연결해서 콜라를 분무할 수도 있습니다. <br><br>

            - 몸통은 물을 저장합니다. 따라서 용량이 있습니다. <br>
              물통을 큰거나 작은 걸로 바꿀 수 있습니다. <br>
              그냥 바로 꽃을 꼽아서 키울 수도 있습니다. <br><br>

            - 위와같이 각 부위가 어느정도 유연성을 가질 수 있습니다. <br>

        </p>
        <h4>4.2-3 간단히 상태에 따라 분리한 버전</h4>
        <p>
            - 한 곳에 있던 상태를 머리와 몸통으로 나눕니다. <br>
              머리: SprayHead <br>
              몸통: SprayBottle <br><br>

            - 관련 메서드도 각 클래스로 옮깁니다. <br>
              다만 아직 메서드 코드는 바꾸지 않았습니다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -head: SprayHead <br>
                -bottle: SprayBottle <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(SprayHead, SprayBottle) <br>
                +getHead(): SprayHead <br>
                +getBottle(): SprayBottle <br>
                +setHead(SprayHead) <br>
                +setBottle(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayHead</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -sprayAmount: int <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayHead(int) <br>
                +spray() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayBottle</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWater: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayBottle(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +fillUp() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <h4>4.2-4 WaterSpray는 머리와 몸통의 집합</h4>
        <p>
            <a href="">- Ex040204_WaterSpray_Ver6</a><br><br>

            - 위 예제에서 보셨듯이, 다양한 스펙의 머리와 몸통을 섞을 수 있습니다. <br><br>

            - 즉 머리와 몸통을 독자적인 개체로 인정하였습니다. <br>
              WaterSpray 클래스와의 관계는 집합(Aggregation)입니다. <br>
              클래스 다이어 그램에서는 아래와 같습니다. <br><br>

        </p>

        <table>
          <tbody>
            <tr>
              <td>기호</td>
              <td>클래스들 간의 관계</td>
            </tr>
            <tr>
              <td>────◇</td>
              <td>집합관계</td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <h4>4.2-5 FlowerPot에 사용해 봅시다</h4>
        <p>
            <a href="">Ex040205_SprayToFlowerPot_Ver5</a><br><br>

            - 위 코드의 문제점은 spray() 메서드가 SprayHead 클래스에 있다는 것입니다. <br>
              물은 SprayBottle 클래스에 있는데 말이죠. <br><br>

        </p>
        <h4>4.2-6 spray() 메서드는 몸통을 알아야만 합니다.</h4>
        <p>
            - SprayBottle 클래스에 reduceWater() 메서드를 추가합니다. <br>
              실세계에서 물을 버리는 모습과 유사합니다. <br>
              물을 그냥 따라 버릴 수 있습니다. <br><br>

            - SprayHead 클래스에 spray() 메서드를 sprayFrom() 메서드로 변경합니다. <br>
              이제 SprayBottle 클래스 개체를 인자로 받습니다. <br>
              다른 몸통을 사용하려면 메서드를 추가하셔야 합니다. ex. sparayFrom(ColaBottle) <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -head: SprayHead <br>
                -bottle: SprayBottle <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(SprayHead, SprayBottle) <br>
                +getHead(): SprayHead <br>
                +getBottle(): SprayBottle <br>
                +setHead(SprayHead) <br>
                +setBottle(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayHead</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -sprayAmount: int <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayHead(int) <br>
                +sprayFrom(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayBottle</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWater: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayBottle(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +reduceWater(int) <br>
                +fillUp() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
          <a href="">- Ex040206_SprayToFlowerPot_Ver6</a><br><br>
        </p>

        <h4>4.2-7 유연성 높은 설계가 최고일까요?</h4>
        <p>
            - 그런데 뭔가 너무 복잡한 느낌입니다. <br>
              그냥 중간 크기 분무기 하면 알아서 나왔으면 좋겠는데, 머리랑 몸통을 따로 만들어야 하고 <br>
              분무기는 그냥 분무만 하면 되는데, 물 뿌릴 때 머리와 몸통을 각각 호출해야 합니다. <br>
              지금이야 간단한 예시지만 훨씬 복잡한 프로그램에서 쪼갠다고 생각하면? <br><br>

            - "유연한 설계(~=재사용성 높은 설계)가 최고다."라는 한때 흥했던 OO 설계에 대한 극단적인 주장이 있었습니다. <br>
              이에 기초해서 말도 안되는 규칙들도 주창했습니다. ex. 클래스에 코드가 ~줄 이상이면 안됨. 메서드가 ~개 이상 안됨. <br><br>

            - 과연 재사용성이 높으면 항상 좋을까요? <br>
              그런 경우도 있기는 합니다. 서류 집게를 서류 집게로만 쓰기 보다, 선정리용도로 써도 휼륭하기도 합니다. <br>
              그러나 그 반대의 경우도 있습니다. 자동차의 엔진룸과 엔진을 상상해 봅시다. <br>
              엔진룸의 재사용성이 높다는 것은 어떤 크기의 엔진이 와도 수용할 수 있다는 뜻입니다. <br>
              그렇다면 극단적으로 작은 엔진이 왔을때, 엔진룸에는 낭비가 발생할 수 있다는 뜻과 일맥상통합니다. <br><br>

            - 코드에서도 마찬가지입니다. <br>
              자주 사용하는 코드 여러 줄을 한데 묶어서 함수화를 시키면 편리하지만, <br>
              무턱대고 다 함수화를 시켜버리면 여러 함수들을 넘나 들며 읽어야 합니다. <br>
              좀 더 넓은 범위에서 보자면, 관련 함수들을 담는 파일들이 많아져서 더욱 더 개발을 힘들게 합니다. <br>
              파일 100개를 읽는게 편할까요, 2개를 읽는게 편할까요? 사람의 사고방식을 무시해서는 안됩니다. <br><br>

        </p>
        <h4>4.2-8 코드 유연성은 양날의 검</h4>
        <p>
            - 유연성 높음 == 재사용성 ▲ == 성능 ▼ == 가독성 ▼ <br>
              유연성 낮음 == 재사용성 ▼ == 성능 ▲ == 가독성 ▲ <br><br>

            - 수 십 년 동안 실전에 OOP를 사용하고 업계가 깨달은 것입니다. <br>
              유연하지 않은 클래스를 만드는 경우가 더 빈번하며 그래도 상관없습니다. <br>
              완벽한 진리의 코드는 없습니다. <br>
              어느 정도의 유연성이 필요한지는 각 프로젝트마다 다릅니다. <br>
              필요에 따라 유연성을 유연하게 조정해야만 합니다. <br><br>

        </p>
        <h4>4.2-9 OOP 공부 가이드라인</h4>
        <p>
            - 개체 모델링 시 유연성을 고려하기 앞서 더 중요한 것이 있습니다. <br>
              바로 <b>기본기</b>입니다. <br>
              사칙연산을 못하는데 미적분을 할 수 있을까요? 기본기 없는 유연한 클래스는 모래 위에 세워진 누각입니다.<br><br>

            - 프로그래머의 기본 자세를 확실히 잡아야 합니다. <br>
              첫째. 읽기 명확한 코드를 작성할 것 <br>
              둘째. 실수를 저지르기 어려운 코드를 작성할 것 <br>
              셋째. 문제를 해결하는 코드를 작성할 것 <br>
              넷째. 문제가 생기면 디버깅 할 것 <br><br>

            - 지금까지 배운 OOP 개념들이 이런 자세를 잡는데 도움이 됩니다. <br>
              필요에 따라 점점 유연성을 키우는 방법을 배워 나가야합니다. <br><br>

            - 그럼 머리랑 몸통을 없애고 다시 하나로 가야할까요? <br>
              그건 아닙니다. 간단한 예시이니, 재사용성을 유지하면서도 해결하는 방법이 있습니다. <br><br>

        </p>
        <h4>4.2-11 미리 규격을 정해둡시다.</h4>
        <p>
            - 머리와 물통을 따로 만들어야 하는 문제는 미리 규격을 정해두는 것으로 해결 가능합니다. <br>
              새로운 생성자를 추가하여서, 티셔츠의 사이즈(ex. S, M, L)처럼 규격을 정해 두고자 합니다. <br>
              정확히는 두 열거형을 인자로 받게끔 구현합니다. 하나는 SprayHeadSpeed, 다른 하나는 SprayBottleSize입니다. <br><br>

            - 다른 생성자는 그대로 둬도 됩니다. 재사용성을 유지하기 위해서입니다. <br><br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -head: SprayHead <br>
                -bottle: SprayBottle <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(SprayHead, SprayBottle) <br>
                +WaterSpray(SprayHeadSpeed, SprayBottleSize) <br>
                +getHead(): SprayHead <br>
                +getBottle(): SprayBottle <br>
                +setHead(SprayHead) <br>
                +setBottle(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayHead</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -sprayAmount: int <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayHead(int) <br>
                +sprayFrom(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayBottle</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWater: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayBottle(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +reduceWater(int) <br>
                +fillUp() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
          <a href="">- Ex040211_WaterSpray_Ver7</a><br><br>
        </p>

        <h4>4.2-12 분무기를 직접 사용해 봅시다.</h4>
        <p>
            - 분무기에서 곧바로 분무를 못하고, 머리와 물통을 따로 호출해야 하는 문제를 해결 해 봅시다. <br>
              문제의 코드는 FlowerPot 클래스의 addWater() 메서드입니다. <br><br>

            - 이를 해결하기 위해서 SprayBottle 클래스에 있던 메서드들을 다시 WaterSpray로 복귀시킵니다. <br>
              대부분은 head 혹은 bottle로 호출 릴레이<br>

        </p>

        <table>
          <thead>
            <tr>
              <td><b>WaterSpray</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -head: SprayHead <br>
                -bottle: SprayBottle <br>
              </td>
            </tr>
            <tr>
              <td>
                +WaterSpray(SprayHead, SprayBottle) <br>
                +WaterSpray(SprayHeadSpeed, SprayBottleSize) <br>
                +getHead(): SprayHead <br>
                +getBottle(): SprayBottle <br>
                +setHead(SprayHead) <br>
                +setBottle(SprayBottle) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +fillUp() <br>
                +spray() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayHead</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -sprayAmount: int <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayHead(int) <br>
                +sprayFrom(SprayBottle) <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <table>
          <thead>
            <tr>
              <td><b>SprayBottle</b></td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -capacity: int <br>
                -remainingWater: int = 0 <br>
              </td>
            </tr>
            <tr>
              <td>
                +SprayBottle(int) <br>
                +getCapacity(): int <br>
                +getRemainingWater(): int <br>
                +addWater(int) <br>
                +reduceWater(int) <br>
                +fillUp() <br>
              </td>
            </tr>
          </tbody>
        </table>
        <br><br>

        <p>
            <a href="">- Ex040212_WaterSpray_Ver8</a><br><br>
        </p>

        <h4>4.2-25 완성된 화분에 물뿌리기 시스템</h4>
        <p>
            - 이렇게 해서 화분에 물 뿌리는 시스템 설계가 완성되었습니다. <br><br>

            <a href="">- Ex040225_POCUTunes</a><br><br>

        </p>

        
    </body>
</html>